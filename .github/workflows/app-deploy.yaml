name: Deploy Application Pipeline

on:
  push:
    branches: [ "main", "develop" ]
  pull_request:
    branches: [ "main", "develop" ]
    types: [opened, synchronize]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging
      skip_tests:
        description: 'Skip tests (use with caution)'
        required: false
        default: false
        type: boolean

env:
  GO_VERSION: '1.24.3'
  KUBECTL_VERSION: 'v1.33.0'
  AWS_REGION: us-east-1
  EKS_CLUSTER_NAME: tc-fiap-staging
  ECR_REGISTRY: 687620679899.dkr.ecr.us-east-1.amazonaws.com
  ECR_REPOSITORY: tc-fiap-customer

jobs:
  # Planning and validation
  plan:
    name: 'Plan Deployment'
    runs-on: ubuntu-latest
    outputs:
      deploy_app: ${{ steps.plan.outputs.deploy_app }}
      skip_tests: ${{ steps.plan.outputs.skip_tests }}
      environment: ${{ steps.plan.outputs.environment }}
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 2
    
    - name: Plan deployment
      id: plan
      run: |
        # Simple planning logic
        DEPLOY_APP="false"
        SKIP_TESTS="${{ inputs.skip_tests || 'false' }}"
        ENVIRONMENT="${{ inputs.environment || 'production' }}"
        
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          DEPLOY_APP="true"
        elif [[ "${{ github.event_name }}" == "push" ]]; then
          DEPLOY_APP="true"
        fi
        
        echo "deploy_app=$DEPLOY_APP" >> $GITHUB_OUTPUT
        echo "skip_tests=$SKIP_TESTS" >> $GITHUB_OUTPUT
        echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT

  test:
    name: 'Test, Build & Quality'
    runs-on: ubuntu-latest
    needs: plan
    if: needs.plan.outputs.skip_tests != 'true'
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
    - uses: actions/setup-go@v5
      with:
        go-version: ${{ env.GO_VERSION }}
        cache: true
    - name: Run tests with coverage
      run: |
        go test ./... -coverprofile=coverage.out -covermode=atomic
        go tool cover -func=coverage.out
    - name: SonarCloud Scan
      uses: SonarSource/sonarcloud-github-action@master
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      with:
        args: >
          -Dsonar.verbose=true
          -Dsonar.qualitygate.wait=true
    - run: go build ./...

  docker:
    name: 'Build & Push Docker'
    runs-on: ubuntu-latest
    needs: [plan, test]
    if: |
      always() && 
      needs.plan.outputs.deploy_app == 'true' && 
      github.event_name != 'pull_request' &&
      (needs.test.result == 'success' || needs.plan.outputs.skip_tests == 'true')
    outputs:
      image_tag: ${{ steps.meta.outputs.tags }}
    steps:
    - uses: actions/checkout@v4
    - uses: docker/setup-buildx-action@v3
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
        aws-region: ${{ env.AWS_REGION }}
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}
        tags: |
          type=ref,event=branch
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable=true
    - uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  application:
    name: 'Deploy Application'
    runs-on: ubuntu-latest
    needs: [plan, docker]
    if: |
      always() && 
      needs.plan.outputs.deploy_app == 'true' &&
      github.event_name != 'pull_request' &&
      needs.docker.result == 'success'
    steps:
    - uses: actions/checkout@v4
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
        aws-region: ${{ env.AWS_REGION }}
    - name: Deploy to EC2
      run: |
        echo "ðŸš€ Starting deployment to EC2..."
        
        # Get EC2 instance IP from Terraform outputs
        cd terraform
        EC2_IP=$(terraform output -raw ec2_public_ip 2>/dev/null || echo "")
        
        if [ -z "$EC2_IP" ]; then
          echo "âŒ EC2 instance not found. Run 'terraform apply' first."
          exit 1
        fi
        
        echo "ðŸ“ EC2 Instance: $EC2_IP"
        
        # Get the latest image tag
        IMAGE_TAG=$(echo "${{ needs.docker.outputs.image_tag }}" | tr ',' '\n' | head -n1 | xargs)
        echo "ðŸ³ Using image: $IMAGE_TAG"
        
        # Create update script
        cat > /tmp/update-app.sh << 'SCRIPT'
#!/bin/bash
set -e

# Login to ECR
aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
  docker login --username AWS --password-stdin ${{ env.ECR_REGISTRY }}

# Pull new image
docker pull IMAGE_TAG_PLACEHOLDER

# Stop old container
docker stop tc-fiap-customer 2>/dev/null || true
docker rm tc-fiap-customer 2>/dev/null || true

# Run new container
docker run -d \
  --name tc-fiap-customer \
  --restart unless-stopped \
  -p 8080:8080 \
  -e AWS_REGION=${{ env.AWS_REGION }} \
  -e AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }} \
  -e AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }} \
  -e AWS_SESSION_TOKEN=${{ secrets.AWS_SESSION_TOKEN }} \
  IMAGE_TAG_PLACEHOLDER

echo "âœ… Container updated successfully!"
docker ps | grep tc-fiap-customer
SCRIPT
        
        # Replace placeholder with actual image
        sed -i "s|IMAGE_TAG_PLACEHOLDER|$IMAGE_TAG|g" /tmp/update-app.sh
        
        # Note: SSH deployment requires key setup
        # For now, just show the command
        echo "ðŸ“ To deploy manually via SSH:"
        echo "   scp /tmp/update-app.sh ec2-user@$EC2_IP:/tmp/"
        echo "   ssh ec2-user@$EC2_IP 'chmod +x /tmp/update-app.sh && sudo /tmp/update-app.sh'"
        
        echo "âœ… Deployment script created at /tmp/update-app.sh"
        echo "ðŸŒ Application URL: http://$EC2_IP:8080"
        echo "ðŸ“Š Health check: http://$EC2_IP:8080/health"
        echo "ðŸ“š Swagger: http://$EC2_IP:8080/docs/index.html"
    
    # ============================================
    # DEPLOY EKS (COMENTADO - Use se tiver cluster EKS)
    # ============================================
    # - name: Deploy to EKS (Alternative)
    #   run: |
    #     curl -LO "https://dl.k8s.io/release/${{ env.KUBECTL_VERSION }}/bin/linux/amd64/kubectl"
    #     chmod +x kubectl && sudo mv kubectl /usr/local/bin/
    #     aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}
    #     
    #     # Create AWS credentials secret for DynamoDB access (AWS Academy)
    #     echo "Creating AWS credentials secret for DynamoDB..."
    #     kubectl create secret generic aws-credentials \
    #       --from-literal=AWS_ACCESS_KEY_ID="${{ secrets.AWS_ACCESS_KEY_ID }}" \
    #       --from-literal=AWS_SECRET_ACCESS_KEY="${{ secrets.AWS_SECRET_ACCESS_KEY }}" \
    #       --from-literal=AWS_SESSION_TOKEN="${{ secrets.AWS_SESSION_TOKEN }}" \
    #       --dry-run=client -o yaml | kubectl apply -f -
    #     
    #     echo "âœ… AWS credentials secret created/updated successfully"
    #     
    #     # Deploy with new image
    #     IMAGE_TAG=$(echo "${{ needs.docker.outputs.image_tag }}" | tr ',' '\n' | head -n1 | xargs)
    #     echo "Using image: $IMAGE_TAG"
    #     sed "s|687620679899.dkr.ecr.us-east-1.amazonaws.com/tc-fiap-customer:latest|$IMAGE_TAG|g" k8s/app-deployment.yaml > /tmp/app-final.yaml
    #     
    #     kubectl apply -f /tmp/app-final.yaml
    #     kubectl apply -f k8s/app-service.yaml
    #     kubectl apply -f k8s/app-hpa.yaml
    #     
    #     echo "Deployment completed. Checking status..."
    #     kubectl get deployment app-deployment -o wide
    #     kubectl rollout status deployment/app-deployment --timeout=300s